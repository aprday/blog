<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Javascript," />










<meta name="description" content="Vue简介响应式编程 路由组件化 稳定性模块化 动画 数据绑定 /** *假设有这么两种东西 **/ //数据 var object = {   message: &amp;apos;Hello World!&amp;apos; } //DOM &amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;   {{ message }} &amp;lt;/div&amp;gt;  /** *我们可以这么写 **/   n">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析Vue源码">
<meta property="og:url" content="http://yoursite.com/2017/08/03/深入解析Vue源码/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Vue简介响应式编程 路由组件化 稳定性模块化 动画 数据绑定 /** *假设有这么两种东西 **/ //数据 var object = {   message: &amp;apos;Hello World!&amp;apos; } //DOM &amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;   {{ message }} &amp;lt;/div&amp;gt;  /** *我们可以这么写 **/   n">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-05T06:45:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入解析Vue源码">
<meta name="twitter:description" content="Vue简介响应式编程 路由组件化 稳定性模块化 动画 数据绑定 /** *假设有这么两种东西 **/ //数据 var object = {   message: &amp;apos;Hello World!&amp;apos; } //DOM &amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;   {{ message }} &amp;lt;/div&amp;gt;  /** *我们可以这么写 **/   n">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/03/深入解析Vue源码/"/>





  <title>深入解析Vue源码 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/深入解析Vue源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sophia So Far">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入解析Vue源码</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T11:37:25+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h3><p>响应式编程 路由<br>组件化 稳定性<br>模块化 动画</p>
<p>数据绑定</p>
<pre><code>/**
*假设有这么两种东西
**/
//数据
var object = {
  message: &apos;Hello World!&apos;
}
//DOM
&lt;div id=&quot;example&quot;&gt;
  {{ message }}
&lt;/div&gt;

/**
*我们可以这么写
**/


new Vue({
  el: &apos;#example&apos;,
  data: object
})

/**
* 如果有个数据
**/

var object1 = {
  message: &apos;Hello World!&apos;
}

var object2 = {
  message: &apos;Hello World!&apos;
}

//DOM
&lt;div id=&quot;example1&quot;&gt;
  {{ message }}
&lt;/div&gt;

&lt;div id=&quot;example2&quot;&gt;
  {{ message }}
&lt;/div&gt;

/**
*我们还可以这么写
**/

var vm1 = new Vue({el: &apos;#example1&apos;,data: object})
//改变vm1的数据DOM随之改变
vm2.message = &apos;oliver&apos;

var vm2 = new Vue({el: &apos;#example2&apos;,data: object})

vm2.message = &apos;lisa&apos;
</code></pre><p>组件化<br>    var Example = Vue.extend({<br>    template: ‘<div></div>‘,<br>    data: function () {<br>    return {<br>      message: ‘Hello Vue.js!’<br>    }<br>    }<br>    })</p>
<pre><code>// 将该组件注册为 &lt;example&gt; 标签
Vue.component(&apos;example&apos;, Example)

Vue 在组件化上和 React 类似：一切都是组件。
组件使用上也和React一致:

&lt;example&gt;&lt;/example&gt;
</code></pre><p>组件之间数据传递:<br>    1.用 props 来定义如何接收外部数据;<br>    Vue.component(‘child’, {<br>      // 声明 props<br>      props: [‘msg’],<br>      // prop 可以用在模板内<br>      // 可以用 <code>this.msg</code> 设置<br>      template: ‘<span></span>‘<br>    })<br>    <child msg="hello!"></child></p>
<pre><code>2.用自定义事件来向外传递消息;
使用 $on() 监听事件；
使用 $emit() 在它上面触发事件；
使用 $dispatch() 派发事件，事件沿着父链冒泡；
使用 $broadcast() 广播事件，事件向下传导给所有的后代。

3.用 &lt;slot&gt; API 来将外部动态传入的内容（其他组件或是 HTML）和自身模板进行组合;
</code></pre><p>模块化</p>
<pre><code>Webpack 或者 Browserify，然后再加上 ES2015配合 vue-loader 或是 vueify，就可以把Vue的每一个组件变成
Web Components

&lt;!-- MyComponent.vue --&gt;

&lt;!-- css --&gt;
&lt;style&gt;
.message {
  color: red;
}
&lt;/style&gt;

&lt;!-- template --&gt;
&lt;template&gt;
  &lt;div class=&quot;message&quot;&gt;{{ message }}&lt;/div&gt;
&lt;/template&gt;

&lt;!-- js --&gt;
&lt;script&gt;
export default {
  props: [&apos;message&apos;],
  created() {
    console.log(&apos;MyComponent created!&apos;)
  }
}
&lt;/script&gt;
</code></pre><p>路由</p>
<pre><code>使用Vue重构的Angular项目

www.songxuemeng.com/diary

个人感觉vue-router烦的问题是组件之间的数据交互,rootRouter的数据很难向其他组件传递.

/**
*解决方法
**/
var app = Vue.extend({
  data:function(){
      return {
          data:&apos;&apos;,
      };
  },
});
router.map({
      &apos;/&apos;: {
          component:  Vue.extend({
                            mixins: [calendar.mixin],
                            data:function(){
                                return {
                                    data:data
                                }
                            }
                      })
      },
  })
router.start(app, &apos;#app&apos;);
</code></pre><p>###Vue源码分析</p>
<p><a href="http://img2.tbcdn.cn/L1/461/1/8142ef3fc2055839f1a93a933d80e17694b4f76b" target="_blank" rel="external">http://img2.tbcdn.cn/L1/461/1/8142ef3fc2055839f1a93a933d80e17694b4f76b</a></p>
<p>Vue.js是一个典型的MVVM的程序结构，程序大体可以分为：<br>全局设计：包括全局接口、默认选项等；<br>vm实例设计：包括接口(vm原形)、实例初始化过程(vm构造函数)</p>
<p>下面是构造函数最核心的工作内容。</p>
<p><a href="http://img3.tbcdn.cn/L1/461/1/00049a09def4aff8d80f3bb7229e3f6d395426fb" target="_blank" rel="external">http://img3.tbcdn.cn/L1/461/1/00049a09def4aff8d80f3bb7229e3f6d395426fb</a></p>
<p>整个实例初始化的过程中，重中之重就是把数据 (Model) 和视图 (View) 建立起关联关系。Vue.js 和诸多 MVVM 的思路是类似的，主要做了三件事：</p>
<p>通过 observer 对 data 进行了监听，并且提供订阅某个数据项的变化的能力<br>把 template 解析成一段 document fragment，然后解析其中的 directive，得到每一个 directive 所依赖的数据项及其更新方法。比如 v-text=”message” 被解析之后；<br>所依赖的数据项 this.$data.message，以及<br>相应的视图更新方法 node.textContent = this.$data.message<br>通过 watcher 把上述两部分结合起来，即把 directive 中的数据依赖订阅在对应数据的 observer 上，这样当数据变化的时候，就会触发 observer，进而触发相关依赖对应的视图更新方法，最后达到模板原本的关联效果。<br>所以整个 vm 的核心，就是如何实现 observer, directive (parser), watcher 这三样东西</p>
<p>####vue文件结构</p>
<p><a href="http://img4.tbcdn.cn/L1/461/1/cb73a147451157e52500734c0d31665a9540adae" target="_blank" rel="external">http://img4.tbcdn.cn/L1/461/1/cb73a147451157e52500734c0d31665a9540adae</a></p>
<p>####数据列表的更新</p>
<p>视图更新效率的焦点问题主要在于大列表的更新和深层数据更新这两方面.</p>
<p>但是工作中经常用的主要是前者</p>
<p>首先 diff(data, oldVms) 这个函数的注释对整个比对更新机制做了个简要的阐述，大概意思是先比较新旧两个列表的 vm 的数据的状态，然后差量更新 DOM。</p>
<p>第一步：便利新列表里的每一项，如果该项的 vm 之前就存在，则打一个 _reused 的标，如果不存在对应的 vm，则创建一个新的。</p>
<pre><code>for (i = 0, l = data.length; i &lt; l; i++) {
        item = data[i];
        key = convertedFromObject ? item.$key : null;
        value = convertedFromObject ? item.$value : item;
        primitive = !isObject(value);
        frag = !init &amp;&amp; this.getCachedFrag(value, i, key);
        if (frag) {
          // reusable fragment如果存在打上usered
          frag.reused = true;
          // update $index
          frag.scope.$index = i;
          // update $key
          if (key) {
            frag.scope.$key = key;
          }
          // update iterator
          if (iterator) {
            frag.scope[iterator] = key !== null ? key : i;
          }
          // update data for track-by, object repeat &amp;
          // primitive values.
          if (trackByKey || convertedFromObject || primitive) {
            frag.scope[alias] = value;
          }
        } else {
          // new isntance如果不存在就新建一个
          frag = this.create(value, alias, i, key);
          frag.fresh = !init;
        }
        frags[i] = frag;
        if (init) {
          frag.before(end);
        }
      }
</code></pre><p>第二步：便利旧列表里的每一项，如果 _reused 的标没有被打上，则说明新列表里已经没有它了，就地销毁该 vm。</p>
<pre><code>for (i = 0, l = oldFrags.length; i &lt; l; i++) {
    frag = oldFrags[i];
    if (!frag.reused) {
//如果没有used说明不存在,就地销毁
      this.deleteCachedFrag(frag);
      this.remove(frag, removalIndex++, totalRemoved, inDocument);
    }
  }
</code></pre><p>第三步：整理新的 vm 在视图里的顺序，同时还原之前打上的 _reused 标。就此列表更新完成</p>
<pre><code>for (i = 0, l = frags.length; i &lt; l; i++) {
        frag = frags[i];
        // this is the frag that we should be after
        targetPrev = frags[i - 1];
        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
        if (frag.reused &amp;&amp; !frag.staggerCb) {
          currentPrev = findPrevFrag(frag, start, this.id);
          if (currentPrev !== targetPrev &amp;&amp; (!currentPrev ||
          // optimization for moving a single item.
          // thanks to suggestions by @livoras in #1807
          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
            this.move(frag, prevEl);
          }
        } else {
          // new instance, or still in stagger.
          // insert with updated stagger index.
          this.insert(frag, insertionIndex++, prevEl, inDocument);
        }
//还原打上的used
        frag.reused = frag.fresh = false;
      }
</code></pre><p>keep-alive<br>          Vue.js 为其组件设计了一个 [keep-alive] 的特性，如果这个特性存在，那么在组件被重复创建的时候，会通过缓存机制快速创建组件，以提升视图更新的性能。</p>
<pre><code>          bind: function bind() {
      if (!this.el.__vue__) {
        // keep-alive cache
        this.keepAlive = this.params.keepAlive;
        if (this.keepAlive) {
          this.cache = {};
        }
.....
}
</code></pre><h3 id="数据监听机制"><a href="#数据监听机制" class="headerlink" title="数据监听机制"></a>数据监听机制</h3><h4 id="对象数据监听"><a href="#对象数据监听" class="headerlink" title="对象数据监听"></a>对象数据监听</h4><p>‘Vue’使用’Object.defineProperty’这个’API’为想要监听的属性增加了对应的’getter’和’setter’,每次数据改变的时候在setter中触发函数’dep.notify()’,来达到数据监听的效果</p>
<pre><code>//对要监听的属性使用Object.defineProperty重写get和set函数,增加setter和getter方法
  Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          //增加getter
          var value = getter ? getter.call(obj) : val;
          if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
          }
          if (isArray(value)) {
            for (var e, i = 0, l = value.length; i &lt; l; i++) {
              e = value[i];
              e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();
            }
          }
        }
          return value;
        },
        set: function reactiveSetter(newVal) {
          var value = getter ? getter.call(obj) : val;
          //在属性set value的时候调用!!!
          if (newVal === value) {
            return;
          }
          //增加setter
          if (setter) {
            setter.call(obj, newVal);
          } else {
            val = newVal;
          }
          childOb = observe(newVal);
          //最后调用一个自己的函数
          dep.notify();
        }
      });

      然后dep.notify()都做了什么呢?
      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dep.prototype.notify = function () &#123;</div><div class="line">  // stablize the subscriber list first</div><div class="line">  var subs = toArray(this.subs)</div><div class="line">  for (var i = 0, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">    //对相应的数据进行更新</div><div class="line">    subs[i].update()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      dep在文档里面定义是:
      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//A dep is an observable that can have multiple</div><div class="line">//directives subscribing to it.</div><div class="line">export default function Dep () &#123;</div><div class="line">  this.id = uid++</div><div class="line">  this.subs = []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>‘dep’是维护数据的一个数组,对应着一个’watcher’对象</p>
<p>所以整个数据监听的完成是靠set给属性提供一个setter然后当数据更新时,dep会触发watcher对象,返回新值.</p>
<p>之后会有更详细解释</p>
<p>数组可能会有点麻烦，Vue.js 采取的是对几乎每一个可能改变数据的方法进行 prototype 更改：</p>
<pre><code>;[&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;].forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      // avoid leaking arguments:
      // http://jsperf.com/closure-with-arguments
      var i = arguments.length;
      var args = new Array(i);
      while (i--) {
        args[i] = arguments[i];
      }
      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case &apos;push&apos;:
          inserted = args;
          break;
        case &apos;unshift&apos;:
          inserted = args;
          break;
        case &apos;splice&apos;:
          inserted = args.slice(2);
          break;
      }
      if (inserted) ob.observeArray(inserted);
      // notify change
      ob.dep.notify();
      return result;
    });
  });
</code></pre><p>同时 Vue.js 提供了两个额外的“糖方法” $set 和 $remove 来弥补这方面限制带来的不便。</p>
<p>但这个策略主要面临两个问题：</p>
<p>无法监听数据的 length，导致 arr.length 这样的数据改变无法被监听<br>通过角标更改数据，即类似 arr[2] = 1 这样的赋值操作，也无法被监听</p>
<p>为此 Vue.js 在文档中明确提示不建议直接角标修改数据</p>
<p>“实例计算属性。getter 和 setter 的 this 自动地绑定到实例。”</p>
<p>举个栗子:</p>
<pre><code>var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取，值只须为函数
    b: function () {
      return this.a * 2
    },
    // 读取和设置
    c: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
  })
</code></pre><p>可以看出来computed可以提供自定义一个属性c的getter和setter/b的getter,问题是c和b怎么维护和a的关系</p>
<p>下面是computed怎么提供属性setter和getter的代码:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//初始化computed</div><div class="line">...</div><div class="line">var userDef = computed[key];</div><div class="line">//userDef指的是computed属性,this -&gt; computed</div><div class="line">def.get = makeComputedGetter(userDef, this);</div><div class="line">//或者makeComputedGetter(userDef.get, this)</div><div class="line">...</div><div class="line">function makeComputedGetter(getter, owner) &#123;</div><div class="line">    var watcher = new Watcher(owner, getter, null, &#123;</div><div class="line">      lazy: true</div><div class="line">    &#125;);</div><div class="line">    return function computedGetter() &#123;</div><div class="line">      if (watcher.dirty) &#123;</div><div class="line">        watcher.evaluate();</div><div class="line">      &#125;</div><div class="line">      if (Dep.target) &#123;</div><div class="line">        watcher.depend();</div><div class="line">      &#125;</div><div class="line">      return watcher.value;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><p>computed在建立的时候绑定一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。</p>
<h3 id="视图解析过程"><a href="#视图解析过程" class="headerlink" title="视图解析过程"></a>视图解析过程</h3><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>parsers/path.js 主要的职责是可以把一个 JSON 数据里的某一个“路径”下的数据取出来，比如：</p>
<pre><code>var path = &apos;a.b[1].v&apos;
var obj = {
  a: {
    b: [
      {v: 1},
      {v: 2},
      {v: 3}
    ]
  }
}
parse(obj, path) // 2

var pathStateMachine = []

pathStateMachine[BEFORE_PATH] = {
  &apos;ws&apos;: [BEFORE_PATH],
  &apos;ident&apos;: [IN_IDENT, APPEND],
  &apos;[&apos;: [IN_SUB_PATH],
  &apos;eof&apos;: [AFTER_PATH]
}

pathStateMachine[IN_PATH] = {
  &apos;ws&apos;: [IN_PATH],
  &apos;.&apos;: [BEFORE_IDENT],
  &apos;[&apos;: [IN_SUB_PATH],
  &apos;eof&apos;: [AFTER_PATH]
}

pathStateMachine[BEFORE_IDENT] = {
  &apos;ws&apos;: [BEFORE_IDENT],
  &apos;ident&apos;: [IN_IDENT, APPEND]
}

pathStateMachine[IN_IDENT] = {
  &apos;ident&apos;: [IN_IDENT, APPEND],
  &apos;0&apos;: [IN_IDENT, APPEND],
  &apos;number&apos;: [IN_IDENT, APPEND],
  &apos;ws&apos;: [IN_PATH, PUSH],
  &apos;.&apos;: [BEFORE_IDENT, PUSH],
  &apos;[&apos;: [IN_SUB_PATH, PUSH],
  &apos;eof&apos;: [AFTER_PATH, PUSH]
}

pathStateMachine[IN_SUB_PATH] = {
  &quot;&apos;&quot;: [IN_SINGLE_QUOTE, APPEND],
  &apos;&quot;&apos;: [IN_DOUBLE_QUOTE, APPEND],
  &apos;[&apos;: [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  &apos;]&apos;: [IN_PATH, PUSH_SUB_PATH],
  &apos;eof&apos;: ERROR,
  &apos;else&apos;: [IN_SUB_PATH, APPEND]
}

pathStateMachine[IN_SINGLE_QUOTE] = {
  &quot;&apos;&quot;: [IN_SUB_PATH, APPEND],
  &apos;eof&apos;: ERROR,
  &apos;else&apos;: [IN_SINGLE_QUOTE, APPEND]
}

pathStateMachine[IN_DOUBLE_QUOTE] = {
  &apos;&quot;&apos;: [IN_SUB_PATH, APPEND],
  &apos;eof&apos;: ERROR,
  &apos;else&apos;: [IN_DOUBLE_QUOTE, APPEND]
}
</code></pre><p>状态机可以完成</p>
<pre><code>1.dom结构中{{data.someObj}}的解析;
2.对字符型json的取值;
</code></pre><p>可惜大学里面的编译原理我给忘记了,否则可以给大家解析一下.</p>
<h4 id="视图解析过程-1"><a href="#视图解析过程-1" class="headerlink" title="视图解析过程"></a>视图解析过程</h4><p>视图的解析过程，Vue.js 的策略是把 element 或 template string 先统一转换成 document fragment，然后再分解和解析其中的子组件和 directives。</p>
<p>相比React的visual DOM有一定的性能优化空间，毕竟 DOM 操作相比纯 JavaScript 运算还是会慢一些。</p>
<h3 id="Vue扩展"><a href="#Vue扩展" class="headerlink" title="Vue扩展"></a>Vue扩展</h3><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>Mixin (混入) 是一种可以在多个 Vue 组件之间灵活复用特性的机制。你可以像写一个普通 Vue 组件的选项对象一样编写一个 mixin：</p>
<pre><code>module.exports = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log(&apos;hello from mixin!&apos;)
    }
  }
}



// test.js
var myMixin = require(&apos;./mixin&apos;)
var Component = Vue.extend({
  mixins: [myMixin]
})
var component = new Component() // -&gt; &quot;hello from mixin!&quot;
</code></pre><h4 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h4><pre><code>Vue插件类型分为以下几种:

1.添加一个或几个全局方法。比如 vue-element
2.添加一个或几个全局资源：指令、过滤器、动画效果等。比如
vue-touch
3.通过绑定到 Vue.prototype 的方式添加一些 Vue 实例方法。这里有个约定，就是 Vue 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。
</code></pre><h5 id="开发Vue插件"><a href="#开发Vue插件" class="headerlink" title="开发Vue插件"></a>开发Vue插件</h5><pre><code>MyPlugin.install = function (Vue, options) {
// 1. 添加全局方法或属性
Vue.myGlobalMethod = ...
// 2. 添加全局资源
Vue.directive(&apos;my-directive&apos;, {})
// 3. 添加实例方法
Vue.prototype.$myMethod = ...
}
</code></pre><h5 id="使用Vue插件"><a href="#使用Vue插件" class="headerlink" title="使用Vue插件"></a>使用Vue插件</h5><pre><code>var vueTouch = require(&apos;vue-touch&apos;)
// use the plugin globally
Vue.use(vueTouch)
你也可以向插件里传递额外的选项：

Vue.use(require(&apos;my-plugin&apos;), {
/* pass in additional options */
})

全局方法:
Vue.fun()
局部方法:
vm.$fun()
</code></pre><h4 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h4><p>Vue.js 允许注册自定义指令，实质上是开放 Vue 一些技巧：怎样将数据的变化映射到 DOM 的行为。你可以使用 Vue.directive(id, definition) 的方法传入指令 id 和定义对象来注册一个全局自定义指令。定义对象需要提供一些钩子函数：<br>bind： 仅调用一次，当指令第一次绑定元素的时候。<br>update： 第一次是紧跟在 bind 之后调用，获得的参数是绑定的初始值；以后每当绑定的值发生变化就会被调用，获得新值与旧值两个参数。<br>unbind：仅调用一次，当指令解绑元素的时候。</p>
<p>一旦注册好自定义指令，你就可以在 Vue.js 模板中像这样来使用它（需要添加 Vue.js 的指令前缀，默认为 <code>v-</code>）：</p>
<p><code>&lt;div v-my-directive=&quot;someValue&quot;&gt;&lt;/div&gt;</code></p>
<p>如果你只需要 <code>update</code> 函数，你可以只传入一个函数，而不用传定义对象：</p>
<figure class="highlight plain"><figcaption><span>function (value) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  // 这个函数会被作为 update() 函数使用</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所有的钩子函数会被复制到实际的<strong>指令对象</strong>中，而这个指令对象将会是所有钩子函数的 <code>this</code> 上下文环境。指令对象上暴露了一些有用的公开属性：</p>
<ul>
<li><strong>el</strong>： 指令绑定的元素</li>
<li><strong>vm</strong>： 拥有该指令的上下文 ViewModel</li>
<li><strong>expression</strong>： 指令的表达式，不包括参数和过滤器</li>
<li><strong>arg</strong>： 指令的参数</li>
<li><strong>raw</strong>： 未被解析的原始表达式</li>
<li><strong>name</strong>： 不带前缀的指令名</li>
</ul>
<blockquote>
<p>这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。</p>
</blockquote>
<p>使用指令对象属性的示例：</p>
<p><code>&lt;div id=&quot;demo&quot; v-demo=&quot;LightSlateGray : msg&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  bind: function () &#123;</div><div class="line">    this.el.style.color = &apos;#fff&apos;</div><div class="line">    this.el.style.backgroundColor = this.arg</div><div class="line">  &#125;,</div><div class="line">  update: function (value) &#123;</div><div class="line">    this.el.innerHTML =</div><div class="line">      &apos;name - &apos;       + this.name + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;raw - &apos;        + this.raw + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;expression - &apos; + this.expression + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;argument - &apos;   + this.arg + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;value - &apos;      + value</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">var demo = new Vue(&#123;</div><div class="line">  el: &apos;#demo&apos;,</div><div class="line">  data: &#123;</div><div class="line">    msg: &apos;hello!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>Result</strong></p>
<ul>
<li>name - demo</li>
<li>raw - LightSlateGray：msg</li>
<li>expression - msg</li>
<li>argument - LightSlateGray</li>
<li>value - hello!</li>
</ul>
<h3 id="多重从句"><a href="#多重从句" class="headerlink" title="多重从句"></a>多重从句</h3><p>同一个特性内部，逗号分隔的多个从句将被绑定为多个指令实例。在下面的例子中，指令会被创建和调用两次：</p>
<p><code>&lt;div v-demo=&quot;color: &#39;white&#39;, text: &#39;hello!&#39;&quot;&gt;&lt;/div&gt;</code></p>
<p>如果想要用单个指令实例处理多个参数，可以利用字面量对象作为表达式：</p>
<p><code>&lt;div v-demo=&quot;{color: &#39;white&#39;, text: &#39;hello!&#39;}&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>function (value) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  console.log(value) // Object &#123;color: &apos;white&apos;, text: &apos;hello!&apos;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="字面指令"><a href="#字面指令" class="headerlink" title="字面指令"></a>字面指令</h2><p>如果在创建自定义指令的时候传入 <code>isLiteral: true</code>，那么特性值就会被看成直接字符串，并被赋值给该指令的 <code>expression</code>。字面指令不会试图建立数据监视。</p>
<p><strong>Example</strong>：</p>
<p><code>&lt;div v-literal-dir=&quot;foo&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  isLiteral: true,</div><div class="line">  bind: function () &#123;</div><div class="line">    console.log(this.expression) // &apos;foo&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="动态字面指令"><a href="#动态字面指令" class="headerlink" title="动态字面指令"></a>动态字面指令</h3><p>然而，在字面指令含有 <code>Mustache</code> 标签的情形下，指令的行为如下：</p>
<ul>
<li><p>指令实例会有一个属性，<code>this._isDynamicLiteral</code> 被设为 <code>true</code>；</p>
</li>
<li><p>如果没有提供 <code>update</code> 函数，<code>Mustache</code> 表达式只会被求值一次，并将该值赋给 <code>this.expression</code> 。不会对表达式进行数据监视。</p>
</li>
<li><p>如果提供了 <code>update</code> 函数，指令将会为表达式建立一个数据监视，并且在计算结果变化的时候调用 <code>update</code>。</p>
</li>
</ul>
<h2 id="双向指令"><a href="#双向指令" class="headerlink" title="双向指令"></a>双向指令</h2><p>如果你的指令想向 Vue 实例写回数据，你需要传入 <code>twoWay: true</code> 。该选项允许在指令中使用 <code>this.set(value)</code>。</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  twoWay: true,</div><div class="line">  bind: function () &#123;</div><div class="line">    this.handler = function () &#123;</div><div class="line">      // 把数据写回 vm</div><div class="line">      // 如果指令这样绑定 v-example=&quot;a.b.c&quot;,</div><div class="line">      // 这里将会给 `vm.a.b.c` 赋值</div><div class="line">      this.set(this.el.value)</div><div class="line">    &#125;.bind(this)</div><div class="line">    this.el.addEventListener(&apos;input&apos;, this.handler)</div><div class="line">  &#125;,</div><div class="line">  unbind: function () &#123;</div><div class="line">    this.el.removeEventListener(&apos;input&apos;, this.handler)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="内联语句"><a href="#内联语句" class="headerlink" title="内联语句"></a>内联语句</h2><p>传入 <code>acceptStatement: true</code> 可以让自定义指令像 <code>v-on</code> 一样接受内联语句：</p>
<p><code>&lt;div v-my-directive=&quot;a++&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  acceptStatement: true,</div><div class="line">  update: function (fn) &#123;</div><div class="line">    // the passed in value is a function which when called,</div><div class="line">    // will execute the &quot;a++&quot; statement in the owner vm&apos;s</div><div class="line">    // scope.</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>但是请明智地使用此功能，因为通常我们希望避免在模板中产生副作用。</p>
<h2 id="深度数据观察"><a href="#深度数据观察" class="headerlink" title="深度数据观察"></a>深度数据观察</h2><p>如果你希望在一个对象上使用自定义指令，并且当对象内部嵌套的属性发生变化时也能够触发指令的 <code>update</code> 函数，那么你就要在指令的定义中传入 <code>deep: true</code>。</p>
<p><code>&lt;div v-my-directive=&quot;obj&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  deep: true,</div><div class="line">  update: function (obj) &#123;</div><div class="line">    // 当 obj 内部嵌套的属性变化时也会调用此函数</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="指令优先级"><a href="#指令优先级" class="headerlink" title="指令优先级"></a>指令优先级</h2><p>你可以选择给指令提供一个优先级数（默认是 0）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。</p>
<p>通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 <code>v-repeat</code>， <code>v-if</code> 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。</p>
<h2 id="元素指令"><a href="#元素指令" class="headerlink" title="元素指令"></a>元素指令</h2><p>有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 <code>Angular</code> 的 <code>E</code> 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">  // 和普通指令的 API 一致</div><div class="line">  bind: function () &#123;</div><div class="line">    // 对 this.el 进行操作...</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">### Vue扩展</div><div class="line"></div><div class="line">#### Mixin</div><div class="line"></div><div class="line">Mixin (混入) 是一种可以在多个 Vue 组件之间灵活复用特性的机制。你可以像写一个普通 Vue 组件的选项对象一样编写一个 mixin：</div><div class="line"></div><div class="line">    module.exports = &#123;</div><div class="line">      created: function () &#123;</div><div class="line">        this.hello()</div><div class="line">      &#125;,</div><div class="line">      methods: &#123;</div><div class="line">        hello: function () &#123;</div><div class="line">          console.log(&apos;hello from mixin!&apos;)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // test.js</div><div class="line">    var myMixin = require(&apos;./mixin&apos;)</div><div class="line">    var Component = Vue.extend(&#123;</div><div class="line">      mixins: [myMixin]</div><div class="line">    &#125;)</div><div class="line">    var component = new Component() // -&gt; &quot;hello from mixin!&quot;</div><div class="line"></div><div class="line">#### Vue插件</div><div class="line">    Vue插件类型分为以下几种:</div><div class="line"></div><div class="line">    1.添加一个或几个全局方法。比如 vue-element</div><div class="line">    2.添加一个或几个全局资源：指令、过滤器、动画效果等。比如</div><div class="line">    vue-touch</div><div class="line">    3.通过绑定到 Vue.prototype 的方式添加一些 Vue 实例方法。这里有个约定，就是 Vue 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。</div><div class="line"></div><div class="line">##### 开发Vue插件</div><div class="line"></div><div class="line">    MyPlugin.install = function (Vue, options) &#123;</div><div class="line">    // 1. 添加全局方法或属性</div><div class="line">    Vue.myGlobalMethod = ...</div><div class="line">    // 2. 添加全局资源</div><div class="line">    Vue.directive(&apos;my-directive&apos;, &#123;&#125;)</div><div class="line">    // 3. 添加实例方法</div><div class="line">    Vue.prototype.$myMethod = ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">##### 使用Vue插件</div><div class="line"></div><div class="line">    var vueTouch = require(&apos;vue-touch&apos;)</div><div class="line">    // use the plugin globally</div><div class="line">    Vue.use(vueTouch)</div><div class="line">    你也可以向插件里传递额外的选项：</div><div class="line"></div><div class="line">    Vue.use(require(&apos;my-plugin&apos;), &#123;</div><div class="line">    /* pass in additional options */</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    全局方法:</div><div class="line">    Vue.fun()</div><div class="line">    局部方法:</div><div class="line">    vm.$fun()</div><div class="line"></div><div class="line">#### Vue指令</div><div class="line"></div><div class="line">Vue.js 允许注册自定义指令，实质上是开放 Vue 一些技巧：怎样将数据的变化映射到 DOM 的行为。你可以使用 Vue.directive(id, definition) 的方法传入指令 id 和定义对象来注册一个全局自定义指令。定义对象需要提供一些钩子函数：</div><div class="line">bind： 仅调用一次，当指令第一次绑定元素的时候。</div><div class="line">update： 第一次是紧跟在 bind 之后调用，获得的参数是绑定的初始值；以后每当绑定的值发生变化就会被调用，获得新值与旧值两个参数。</div><div class="line">unbind：仅调用一次，当指令解绑元素的时候。</div><div class="line"></div><div class="line">一旦注册好自定义指令，你就可以在 Vue.js 模板中像这样来使用它（需要添加 Vue.js 的指令前缀，默认为 `v-`）：</div><div class="line"></div><div class="line">`&lt;div v-my-directive=&quot;someValue&quot;&gt;&lt;/div&gt;`</div><div class="line"></div><div class="line">如果你只需要 `update` 函数，你可以只传入一个函数，而不用传定义对象：</div><div class="line"></div><div class="line">```Vue.directive(&apos;my-directive&apos;, function (value) &#123;</div><div class="line">  // 这个函数会被作为 update() 函数使用</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所有的钩子函数会被复制到实际的<strong>指令对象</strong>中，而这个指令对象将会是所有钩子函数的 <code>this</code> 上下文环境。指令对象上暴露了一些有用的公开属性：</p>
<ul>
<li><strong>el</strong>： 指令绑定的元素</li>
<li><strong>vm</strong>： 拥有该指令的上下文 ViewModel</li>
<li><strong>expression</strong>： 指令的表达式，不包括参数和过滤器</li>
<li><strong>arg</strong>： 指令的参数</li>
<li><strong>raw</strong>： 未被解析的原始表达式</li>
<li><strong>name</strong>： 不带前缀的指令名</li>
</ul>
<blockquote>
<p>这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。</p>
</blockquote>
<p>使用指令对象属性的示例：</p>
<p><code>&lt;div id=&quot;demo&quot; v-demo=&quot;LightSlateGray : msg&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  bind: function () &#123;</div><div class="line">    this.el.style.color = &apos;#fff&apos;</div><div class="line">    this.el.style.backgroundColor = this.arg</div><div class="line">  &#125;,</div><div class="line">  update: function (value) &#123;</div><div class="line">    this.el.innerHTML =</div><div class="line">      &apos;name - &apos;       + this.name + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;raw - &apos;        + this.raw + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;expression - &apos; + this.expression + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;argument - &apos;   + this.arg + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;value - &apos;      + value</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">var demo = new Vue(&#123;</div><div class="line">  el: &apos;#demo&apos;,</div><div class="line">  data: &#123;</div><div class="line">    msg: &apos;hello!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>Result</strong></p>
<ul>
<li>name - demo</li>
<li>raw - LightSlateGray：msg</li>
<li>expression - msg</li>
<li>argument - LightSlateGray</li>
<li>value - hello!</li>
</ul>
<h3 id="多重从句-1"><a href="#多重从句-1" class="headerlink" title="多重从句"></a>多重从句</h3><p>同一个特性内部，逗号分隔的多个从句将被绑定为多个指令实例。在下面的例子中，指令会被创建和调用两次：</p>
<p><code>&lt;div v-demo=&quot;color: &#39;white&#39;, text: &#39;hello!&#39;&quot;&gt;&lt;/div&gt;</code></p>
<p>如果想要用单个指令实例处理多个参数，可以利用字面量对象作为表达式：</p>
<p><code>&lt;div v-demo=&quot;{color: &#39;white&#39;, text: &#39;hello!&#39;}&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>function (value) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  console.log(value) // Object &#123;color: &apos;white&apos;, text: &apos;hello!&apos;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="字面指令-1"><a href="#字面指令-1" class="headerlink" title="字面指令"></a>字面指令</h2><p>如果在创建自定义指令的时候传入 <code>isLiteral: true</code>，那么特性值就会被看成直接字符串，并被赋值给该指令的 <code>expression</code>。字面指令不会试图建立数据监视。</p>
<p><strong>Example</strong>：</p>
<p><code>&lt;div v-literal-dir=&quot;foo&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  isLiteral: true,</div><div class="line">  bind: function () &#123;</div><div class="line">    console.log(this.expression) // &apos;foo&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="动态字面指令-1"><a href="#动态字面指令-1" class="headerlink" title="动态字面指令"></a>动态字面指令</h3><p>然而，在字面指令含有 <code>Mustache</code> 标签的情形下，指令的行为如下：</p>
<ul>
<li><p>指令实例会有一个属性，<code>this._isDynamicLiteral</code> 被设为 <code>true</code>；</p>
</li>
<li><p>如果没有提供 <code>update</code> 函数，<code>Mustache</code> 表达式只会被求值一次，并将该值赋给 <code>this.expression</code> 。不会对表达式进行数据监视。</p>
</li>
<li><p>如果提供了 <code>update</code> 函数，指令将会为表达式建立一个数据监视，并且在计算结果变化的时候调用 <code>update</code>。</p>
</li>
</ul>
<h2 id="双向指令-1"><a href="#双向指令-1" class="headerlink" title="双向指令"></a>双向指令</h2><p>如果你的指令想向 Vue 实例写回数据，你需要传入 <code>twoWay: true</code> 。该选项允许在指令中使用 <code>this.set(value)</code>。</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  twoWay: true,</div><div class="line">  bind: function () &#123;</div><div class="line">    this.handler = function () &#123;</div><div class="line">      // 把数据写回 vm</div><div class="line">      // 如果指令这样绑定 v-example=&quot;a.b.c&quot;,</div><div class="line">      // 这里将会给 `vm.a.b.c` 赋值</div><div class="line">      this.set(this.el.value)</div><div class="line">    &#125;.bind(this)</div><div class="line">    this.el.addEventListener(&apos;input&apos;, this.handler)</div><div class="line">  &#125;,</div><div class="line">  unbind: function () &#123;</div><div class="line">    this.el.removeEventListener(&apos;input&apos;, this.handler)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="内联语句-1"><a href="#内联语句-1" class="headerlink" title="内联语句"></a>内联语句</h2><p>传入 <code>acceptStatement: true</code> 可以让自定义指令像 <code>v-on</code> 一样接受内联语句：</p>
<p><code>&lt;div v-my-directive=&quot;a++&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  acceptStatement: true,</div><div class="line">  update: function (fn) &#123;</div><div class="line">    // the passed in value is a function which when called,</div><div class="line">    // will execute the &quot;a++&quot; statement in the owner vm&apos;s</div><div class="line">    // scope.</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>但是请明智地使用此功能，因为通常我们希望避免在模板中产生副作用。</p>
<h2 id="深度数据观察-1"><a href="#深度数据观察-1" class="headerlink" title="深度数据观察"></a>深度数据观察</h2><p>如果你希望在一个对象上使用自定义指令，并且当对象内部嵌套的属性发生变化时也能够触发指令的 <code>update</code> 函数，那么你就要在指令的定义中传入 <code>deep: true</code>。</p>
<p><code>&lt;div v-my-directive=&quot;obj&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  deep: true,</div><div class="line">  update: function (obj) &#123;</div><div class="line">    // 当 obj 内部嵌套的属性变化时也会调用此函数</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="指令优先级-1"><a href="#指令优先级-1" class="headerlink" title="指令优先级"></a>指令优先级</h2><p>你可以选择给指令提供一个优先级数（默认是 0）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。</p>
<p>通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 <code>v-repeat</code>， <code>v-if</code> 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。</p>
<h2 id="元素指令-1"><a href="#元素指令-1" class="headerlink" title="元素指令"></a>元素指令</h2><p>有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 <code>Angular</code> 的 <code>E</code> 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">  // 和普通指令的 API 一致</div><div class="line">  bind: function () &#123;</div><div class="line">    // 对 this.el 进行操作...</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">### vuejs vs angularjs</div><div class="line">    Angular Modules</div><div class="line">    angular.module(&apos;myModule&apos;, [...]);</div><div class="line">    Components</div><div class="line">    Vue.extend(&#123;</div><div class="line">      data: function()&#123; return &#123;...&#125; &#125;,</div><div class="line">      created: function() &#123;...&#125;,</div><div class="line">      ready: function() &#123;...&#125;,</div><div class="line">      components: &#123;...&#125;,</div><div class="line">      methods: &#123;...&#125;,</div><div class="line"></div><div class="line">总体来说</div><div class="line">对于Angular来说module就是一个容器,而对Vue来说一个component里面会有逻辑代码</div><div class="line">在Vue里面会放进许多代码细节,并且有固定的属性</div><div class="line"></div><div class="line">    Directives</div><div class="line">    Angular</div><div class="line">    myModule.directive(&apos;directiveName&apos;, function (injectables) &#123;</div><div class="line">      return &#123;</div><div class="line">        restrict: &apos;A&apos;,</div><div class="line">        template: &apos;&lt;div&gt;&lt;/div&gt;&apos;,</div><div class="line">        controller: function() &#123; ... &#125;,</div><div class="line">        compile: function() &#123;...&#125;,</div><div class="line">        link: function() &#123; ... &#125;</div><div class="line">        //(other props excluded)</div><div class="line">      &#125;;</div><div class="line">    &#125;);</div><div class="line">    Vue</div><div class="line">    Vue.directive(&apos;my-directive&apos;, &#123;</div><div class="line">      bind: function () &#123;...&#125;,</div><div class="line">      update: function (newValue, oldValue) &#123;...&#125;,</div><div class="line">      unbind: function () &#123;...&#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">Vue的指令比Angular的简单,而Angular的指令类似Vue的component</div><div class="line"></div><div class="line">    Filters</div><div class="line">    Angular</div><div class="line">    myModule.angular.module(‘filterName&apos;, [])</div><div class="line">    .filter(&apos;reverse&apos;, function() &#123;</div><div class="line">    return function(input) &#123;...&#125;;</div><div class="line">    &#125;);</div><div class="line">    Vue</div><div class="line">    Vue.filter(&apos;reverse&apos;, function (value) &#123;</div><div class="line">    return function(value)&#123;...&#125;;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">filters都是类似的,但是Vue提供了read/wirte功能</div><div class="line"></div><div class="line">    Templating</div><div class="line">    Interpolation</div><div class="line">    &#123;&#123;myVariable&#125;&#125;</div><div class="line">    Interpolation</div><div class="line">    &#123;&#123;myVariable&#125;&#125;</div><div class="line"></div><div class="line"></div><div class="line">当输出是一个对象的时候</div><div class="line">Vue:[Object]</div><div class="line">Angular :&#123;[attr:value]&#125;</div><div class="line">Vue可以使用filters得到正常输出 &#123;&#123;someObject|json&#125;&#125;</div><div class="line"></div><div class="line">    Model binding</div><div class="line">    Angular</div><div class="line">    &lt;input type=&quot;text&quot; ng-model=&quot;myVar&quot;&gt;</div><div class="line">    &lt;p ng-bind=&quot;myVar&quot;&gt;&lt;/p&gt;</div><div class="line">    Vue</div><div class="line">    &lt;input type=&quot;text&quot; v-model=&quot;myVar&quot;&gt;</div><div class="line">    &lt;p v-model=&quot;myVar&quot;&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">    Loops</div><div class="line">    Angular</div><div class="line">    &lt;li ng-repeat=&quot;item in items&quot; class=&quot;item-&#123;&#123;$index&#125;&#125;&quot;&gt;</div><div class="line">      &#123;&#123;item.myProperty&#125;&#125;</div><div class="line">    &lt;/li&gt;</div><div class="line">    Vue</div><div class="line">    &lt;li v-for=&quot;items&quot; class=&quot;item-&#123;&#123;$index&#125;&#125;&quot;&gt;</div><div class="line">      &#123;&#123;myProperty&#125;&#125;</div><div class="line">    &lt;/li&gt;</div><div class="line"></div><div class="line">    Conditionals</div><div class="line">    Angular</div><div class="line">    &lt;div ng-if=&quot;myVar&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div ng-show=&quot;myVar&quot;&gt;&lt;/div&gt;</div><div class="line">    Vue</div><div class="line">    &lt;div v-if=&quot;myVar&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div v-show=&quot;myVar&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">    Conditional classes</div><div class="line">    Angular</div><div class="line">    &lt;div ng-class=&quot;&#123;‘active’: myVar&#125;&quot;&gt;&lt;/div&gt;</div><div class="line">    Vue</div><div class="line">    &lt;div v-class=&quot;active: myVar&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue也可以这样写v-repeat=&apos;item: items&apos;</div><div class="line"></div><div class="line">    Event binding</div><div class="line">    Angular</div><div class="line">    &lt;div ng-click=&quot;myMethod($event)&quot;&gt;&lt;/div&gt;</div><div class="line">    Vue</div><div class="line">    &lt;div v-on=&quot;click: myMethod($event)&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">通用v-on指令使事件更加一致</div><div class="line"></div><div class="line">#### 脏值检查</div><div class="line">一个电话列表应用的例子，在其中我们会将一个phones数组中的值（在JavaScript中定义）绑定到一个列表项目中以便于我们的数据和UI保持同步：</div><div class="line"></div><div class="line">    &lt;code&gt;&lt;html ng-app&gt;</div><div class="line">      &lt;head&gt;</div><div class="line">    ...</div><div class="line">    &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;controller.js&quot;&gt;&lt;/script&gt;</div><div class="line">      &lt;/head&gt;</div><div class="line">      &lt;body ng-controller=&quot;PhoneListCtrl&quot;&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &lt;li ng-repeat=&quot;phone in phones&quot;&gt;</div><div class="line">    &#123;&#123;phone.name&#125;&#125;</div><div class="line">    &lt;p&gt;&#123;&#123;phone.snippet&#125;&#125;&lt;/p&gt;</div><div class="line">      &lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">      &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div><div class="line">    &lt;/code&gt;</div><div class="line"></div><div class="line">    &lt;code&gt;var phonecatApp = angular.module(&apos;phonecatApp&apos;, []);</div><div class="line"></div><div class="line">    phonecatApp.controller(&apos;PhoneListCtrl&apos;, function($scope) &#123;</div><div class="line">      $scope.phones = [</div><div class="line">    &#123;&apos;name&apos;: &apos;Nexus S&apos;,</div><div class="line">     &apos;snippet&apos;: &apos;Fast just got faster with Nexus S.&apos;&#125;,</div><div class="line">    &#123;&apos;name&apos;: &apos;Motorola XOOM with Wi-Fi&apos;,</div><div class="line">     &apos;snippet&apos;: &apos;The Next, Next Generation tablet.&apos;&#125;,</div><div class="line">    &#123;&apos;name&apos;: &apos;MOTOROLA XOOM&apos;,</div><div class="line">     &apos;snippet&apos;: &apos;The Next, Next Generation tablet.&apos;&#125;</div><div class="line">      ];</div><div class="line">    &#125;);  </div><div class="line">    &lt;/code&gt;</div><div class="line"></div><div class="line">任何时候只要是底层的model数据发生了变化，我们在DOM中的列表也会跟着更新。</div><div class="line"></div><div class="line">脏值检查的基本原理就是只要任何时候数据发生了变化，这个库都会通过一个digest或者change cycle去检查变化是否发生了。在Angular中，一个digest循环意味着所有所有被监视的表达式都会被循环一遍以便查看其中是否有变化发生。它智斗一个模型之前的值因此当变化发生时，一个change事件将会被触发。对于开发者来说，这带来的一大好处就是你可以使用原生的JavaScript对象数据，它易于使用及整合。下面的图片展示的是一个非常糟糕的算法，它的开销非常大。</div><div class="line"></div><div class="line">这个操作的开销和被监视的对象的数量是成正比的。我可能需要做很多的脏治检查。同时当数据发生改变时,我也需要一种方式去触发脏值检查.</div><div class="line"></div><div class="line">相比Angular的脏值检查,Vue的setter/getter方案使数据和DOM更新的时间复杂度降低,数据的更新只发生在数据发生改变时,数据更新的时间复杂度只和数据的观察者有关,&quot;它们拥有一些存取器去获取数据并且能够在你设置或者获取对象时捕获到这些行为并在内部进行广播&quot;.</div><div class="line"></div><div class="line">#### vue的约束的模型系统</div><div class="line"></div><div class="line">而且相比Object.observer()[在es7标准中],Vue的存取方式可以做到比较好的兼容性.</div><div class="line"></div><div class="line">### Vue实现简单的watcher</div><div class="line"></div><div class="line">    1.实现observer</div><div class="line">    2.Vue消息-订阅器</div><div class="line">    3.Watcher的实现</div><div class="line">    4.实现一个Vue</div><div class="line"></div><div class="line">实现一个 $wacth</div></pre></td></tr></table></figure>
<pre><code>const v = new Vue({
  data:{
    a:1,
    b:2
  }
})
v.$watch(&quot;a&quot;,()=&gt;console.log(&quot;哈哈，$watch成功&quot;))
setTimeout(()=&gt;{
  v.a = 5
},2000) //打印 哈哈，$watch成功
```
</code></pre><p>为了帮助大家理清思路。。我们就做最简单的实现。。只考虑对象不考虑数组</p>
<h5 id="实现obserer"><a href="#实现obserer" class="headerlink" title="实现obserer"></a>实现obserer</h5><p>将要observe的对象， 通过递归，将它所有的属性，包括子属性的属性，都给加上set和get， 这样的话，给这个对象的某个属性赋值，就会触发set。就给每个属性（包括子属性）都加上get/set， 这样的话，这个对象的，有任何赋值，就会触发set方法。</p>
<pre><code>export default class  Observer{
  constructor(value) {
    this.value = value
    this.walk(value)
  }
  //递归。。让每个字属性可以observe
  walk(value){
    Object.keys(value).forEach(key=&gt;this.convert(key,value[key]))
  }
  convert(key, val){
    defineReactive(this.value, key, val)
  }
}


export function defineReactive (obj, key, val) {
  var childOb = observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: ()=&gt;val,
    set:newVal=&gt; {      
     childOb = observe(newVal)//如果新赋值的值是个复杂类型。再递归它，加上set/get。。
     }
  })
}


export function observe (value, vm) {
  if (!value || typeof value !== &apos;object&apos;) {
    return
  }
  return new Observer(value)
}
</code></pre><h5 id="消息－订阅器"><a href="#消息－订阅器" class="headerlink" title="消息－订阅器"></a>消息－订阅器</h5><p>维护一个数组，，这个数组，就放订阅着，一旦触发notify， 订阅者就调用自己的update方法</p>
<pre><code>export default class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub){
    this.subs.push(sub)
  }
  notify(){
    this.subs.forEach(sub=&gt;sub.update())
  }
}
</code></pre><p>每次set函数，调用的时候，我们是不是应该，触发notify，对吧。所以 我们把代码补充完整</p>
<pre><code>export function defineReactive (obj, key, val) {
      var dep = new Dep()
      var childOb = observe(val)
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: ()=&gt;val,
        set:newVal=&gt; {
          var value =  val
          if (newVal === value) {
            return
          }
          val = newVal
          childOb = observe(newVal)
          dep.notify()
        }
      })
    }
</code></pre><h5 id="实现一个Watcher"><a href="#实现一个Watcher" class="headerlink" title="实现一个Watcher"></a>实现一个Watcher</h5><pre><code>v.$watch(&quot;a&quot;,()=&gt;console.log(&quot;哈哈，$watch成功&quot;))
</code></pre><p>我们想象这个Watcher，应该用什么东西。update方法，嗯这个毋庸置疑， 还有呢，<br>对表达式（就是那个“a”） 和 回调函数，这是最基本的，所以我们简单写写</p>
<pre><code>export default class Watcher {
  constructor(vm, expOrFn, cb) {
    this.cb = cb
    this.vm = vm
    //此处简化.要区分fuction还是expression,只考虑最简单的expression
    this.expOrFn = expOrFn
    this.value = this.get()
  }
  update(){
    this.run()
  }
  run(){
    const  value = this.get()
    if(value !==this.value){
      this.value = value
      this.cb.call(this.vm)
    }
  }
  get(){
    //此处简化。。要区分fuction还是expression
    const value = this.vm._data[this.expOrFn]
    return value
  }
}
</code></pre><p>怎样将通过addSub(),将Watcher加进去呢。 我们发现var dep = new Dep() 处于闭包当中， 我们又发现Watcher的构造函数里会调用this.get 所以，我们可以在上面动动手脚， 修改一下Object.defineProperty的get要调用的函数， 判断是不是Watcher的构造函数调用，如果是，说明他就是这个属性的订阅者 果断将他addSub()中去，那问题来了， 我怎样判断他是Watcher的this.get调用的，而不是我们普通调用的呢</p>
<pre><code>export default class Watcher {
  ....省略未改动代码....
  get(){
    Dep.target = this
    //此处简化。。要区分fuction还是expression
    const value = this.vm._data[this.expOrFn]
    Dep.target = null
    return value
  }
}
</code></pre><p>这样的话，我们只需要在Object.defineProperty的get要调用的函数里， 判断有没有值，就知道到底是Watcher 在get，还是我们自己在查看赋值，如果 是Watcher的话就addSub(),代码补充一下</p>
<pre><code>export function defineReactive (obj, key, val) {
var dep = new Dep()
var childOb = observe(val)

Object.defineProperty(obj, key, {
enumerable: true,
configurable: true,
get: ()=&gt;{
  // 说明这是watch 引起的
  if(Dep.target){
    dep.addSub(Dep.target)
  }
  return val
},
set:newVal=&gt; {
  var value =  val
  if (newVal === value) {
    return
  }
  val = newVal
  childOb = observe(newVal)
  dep.notify()
}
})
}
</code></pre><p>最后不要忘记，在Dep.js中加上这么一句</p>
<pre><code>Dep.target = null
</code></pre><h5 id="实现一个Vue"><a href="#实现一个Vue" class="headerlink" title="实现一个Vue"></a>实现一个Vue</h5><p>我们要把以上代码配合Vue的$watch方法来用， 要watch Vue实例的属性:</p>
<pre><code>import Watcher from &apos;../watcher&apos;
import {observe} from &quot;../observer&quot;

export default class Vue {
  constructor (options={}) {
    //这里简化了。。其实要merge
    this.$options=options
    //这里简化了。。其实要区分的
    let data = this._data=this.$options.data
    Object.keys(data).forEach(key=&gt;this._proxy(key))
    observe(data,this)
  }


  $watch(expOrFn, cb, options){
    new Watcher(this, expOrFn, cb)
  }

  _proxy(key) {
    var self = this
    Object.defineProperty(self, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter () {
        return self._data[key]
      },
      set: function proxySetter (val) {
        self._data[key] = val
      }
    })
  }
}
</code></pre><p>两件事，observe自己的data，代理自己的data， 使访问自己的属性，就是访问子data的属性。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Javascript/" rel="tag"># Javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/03/异步编程解决方案-generator/" rel="next" title="异步编程解决方案 - generator">
                <i class="fa fa-chevron-left"></i> 异步编程解决方案 - generator
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/03/使用css构造等比例布局/" rel="prev" title="使用css构造等比例布局">
                使用css构造等比例布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sophia So Far</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue简介"><span class="nav-number">1.</span> <span class="nav-text">Vue简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据监听机制"><span class="nav-number">2.</span> <span class="nav-text">数据监听机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象数据监听"><span class="nav-number">2.1.</span> <span class="nav-text">对象数据监听</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图解析过程"><span class="nav-number">3.</span> <span class="nav-text">视图解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析器"><span class="nav-number">4.</span> <span class="nav-text">解析器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#视图解析过程-1"><span class="nav-number">4.1.</span> <span class="nav-text">视图解析过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue扩展"><span class="nav-number">5.</span> <span class="nav-text">Vue扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mixin"><span class="nav-number">5.1.</span> <span class="nav-text">Mixin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue插件"><span class="nav-number">5.2.</span> <span class="nav-text">Vue插件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#开发Vue插件"><span class="nav-number">5.2.1.</span> <span class="nav-text">开发Vue插件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用Vue插件"><span class="nav-number">5.2.2.</span> <span class="nav-text">使用Vue插件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue指令"><span class="nav-number">5.3.</span> <span class="nav-text">Vue指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重从句"><span class="nav-number">6.</span> <span class="nav-text">多重从句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面指令"><span class="nav-number"></span> <span class="nav-text">字面指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态字面指令"><span class="nav-number">1.</span> <span class="nav-text">动态字面指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向指令"><span class="nav-number"></span> <span class="nav-text">双向指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联语句"><span class="nav-number"></span> <span class="nav-text">内联语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度数据观察"><span class="nav-number"></span> <span class="nav-text">深度数据观察</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令优先级"><span class="nav-number"></span> <span class="nav-text">指令优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素指令"><span class="nav-number"></span> <span class="nav-text">元素指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重从句-1"><span class="nav-number">1.</span> <span class="nav-text">多重从句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面指令-1"><span class="nav-number"></span> <span class="nav-text">字面指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态字面指令-1"><span class="nav-number">1.</span> <span class="nav-text">动态字面指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向指令-1"><span class="nav-number"></span> <span class="nav-text">双向指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联语句-1"><span class="nav-number"></span> <span class="nav-text">内联语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度数据观察-1"><span class="nav-number"></span> <span class="nav-text">深度数据观察</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令优先级-1"><span class="nav-number"></span> <span class="nav-text">指令优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素指令-1"><span class="nav-number"></span> <span class="nav-text">元素指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现obserer"><span class="nav-number">0.0.1.</span> <span class="nav-text">实现obserer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消息－订阅器"><span class="nav-number">0.0.2.</span> <span class="nav-text">消息－订阅器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现一个Watcher"><span class="nav-number">0.0.3.</span> <span class="nav-text">实现一个Watcher</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现一个Vue"><span class="nav-number">0.0.4.</span> <span class="nav-text">实现一个Vue</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sophia So Far</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
